## javascript  运行在浏览器的脚本语言   

	  作用：帮助服务器分担压力 使界面更加灵活，生机活力 强大
	        1.简单的数据验证；
	        2.操作页面元素（dom元素）：内容，样式，属性（开始标签里面的东西）
	        3.动态的创建或者删除页面的元素
	        4.动态的写一个动画 
	        5.cookie，本地存储  记录些记忆(浏览器缓存)
	        6.ajax 动态的获取数据
	  组成：1.ecmascript
	          基础的语法：变量的声明，数据类型，运算符，执行的流程，函数，对象，
	        2.bom  浏览器对象模型 browser object  model
	          地址 历史记录 dom  屏幕  
	
	        3.dom document object model
	          节点 （整个文档 头部 标签 属性）
	  引入方式：
	
	        1.页面的任意位置插入script标签对;
	        2.引入外部的js文件
	        3.注意：
	          a.允许引入多个js文件，他们是一个整体 相互联系相互影响相互作用
	          b.外部js文件中，不允许script标签对
	          c.在html文件中引入外部js的语句中，script标签对不允许有jscode
	         <script src="index.js">
	         	
	         </script>
	           
	  调试工具：
	       <script>
	        	  js代码；
	        	  alert(1);警示框;
	        	  alert('dshfhfdhf');
	        	  alert("张三");
	        	  console.log(1);往控制台输出的内容
	        	  document.write(1);往页面中写，识别标签对
	           </script>
	
	  特点：
	       基于对象和事件驱动的松散型解释性语言
	       解释性：由浏览器解释
	       松散型：声明变量是我时候不需要考虑数据类型，存储空间，就一个var就可以了
	               var a=10;
	               语句后的分号加不加都可以
	               var b=10
	               先调用后声明也可以
	       事件驱动: 对应的操作对应的反应
	       对象：
	  变量：
	      存储数据的容器；
	      1.声明变量   var 变量名 =变量值;
	                  let 变量名=变量值；（声明之前不能访问，undefined也没有）
	                                     暂时性的死区
	                                     规范标准
	                      同一个作用域中不允许重复声明同一个变量
	          变量名由数字， 字母 ，下划线 ，$ ，组成
	          数字不能开头
	          关键字不能作为变量名（js已经用过的名字 有特殊含义的 var for）
	          保留字不能作为变量名（class 以后会用到的 ）
	          有意义
	          规则：首字母大写  驼峰命名法   下划线  连字符
	      2.变量赋值
	        先声明后赋值
	        边声名边赋值
	        多个变量的声明赋值一样
	        变量值可以修改
	        变量允许重复声明同一个变量   如果新的变量不赋值，还是原值
	                                   如果给新的变量赋值，新值覆盖旧值
	        声明变量需要var去修饰  不用var赋值且未赋值那么报错
	                             不用var修饰并且赋值，则变成全局变量（不推荐）
	        变量声明了没有赋值 默认值为undefined。赋值之前调用也是undefined
	  数据类型：
	      
	      根据在内存存储的位置
	      
	         初始数据类型（栈区：数据简单，读取快，信息少）
	            undefined
	            number
	            string
	            boolean
	            null
	         复合数据类型（堆区：数据复杂，读取慢，信息大）
	            对象  object
	            
	       检查数据
	          typeof（variable）；typeof variable
	          
	      数据类型      值         typeof
	      undefined    undefined  undefined
	      boolean      true/false  boolean
	      null         null        object
	      number       十进制       number
	                   十六进制(0xff)
	                   二进制(0b111) 
	                   八进制(0o12)
	                   最大值 Number.MAX_VALUE 字符串类型的数字，
	                   最小值 Number.MIN_VALUE
	      
	      string      通过‘’ “”包裹起来的字符(数字 字符 汉字 )    string
	      object      属性和方法的无序集合   object


​	      
​	      
​	      
​	      

| 数据类型      | 值                           | typeof    |
| --------- | --------------------------- | --------- |
| undefined | undefined                   | undefined |
| boolean   | true/false                  | boolean   |
| null      | null                        | object    |
| number    | 十进制，二进制，八进制，十六进制，特殊值        | number    |
| string    | 用''  ""  ``包起来的字符（数字，汉字，字符） | string    |
| object    | 属性和方法的无序集合                  | object    |

string数据类型的变量也可以用制表符括住，可以保留格式，叫做模板字符串，输出其中的变量的用法：

${变量}即可，比较方便。

## 如何操作数据

## 运算符

(  )的两个作用>改变运算的优先级；>调动函数

### 算数运算符

  ‘+ - * / %’   ++  --

​    取余得到某一个范围之内的数

* + 求和   字符串连接

 *var++  先参与运算 后自增

*++var  先自增后参与运算

一块代码有值就是表达式，表达式有值与输不输出没关系

### 赋值运算符（9.5）

=  +=  -=  *=  /=  %=```

> a=a+5    a+=5  (两个用法 求和  拼接   与数字就是求和    与字符串就是拼接)
>
> a=a*2     a *=2

### 关系运算符（比较运算符）

结果是一个布尔值

">"  "<"  "=="  “!="    "==="   ">="   "<="

数字比较：

> ==    1=='1'   true
>
> ==    1==true    true        （布尔值转成数字比较）数值相等即可   数据类型不考虑
>
> ==    1==”true“   false      （字符想转成数字 但是没转成 转成NaN ）表达式返回的就是false
>
> ===  1===true    flase   全等不仅数值相等而且数据类型也相等

字符串比较：

> 首字符ASCII码标准
>
> var num=‘10’  , num1=‘2’    num<num1  ASCII码
>
> var num='10'   num1=2     num>num1   （尝试着将字符转成数字，而且转成了，数字比较）
>
> var num=10     num='2px'   num<    >  num1 (想转成数字，但是没转成，转成了NaN) 表达式返回  的就是false  

特殊

> undefined==null
>
> 但是undefined与true  false  不等

### 逻辑运算符

可以是任意的数据类型

​	```&&(与  and)   ||(或  or)    !(非  not)```

返回的不一定是true和false，还有可能是值

> &&两个都为真，判断两次，返回最后一个为真的值
>
> &&两个都为假，判断一次，返回的是第一个为假的值
>
> &&先真后假 判断两次 返回的是第一个为假的值
>
> &&先假后真  判断一次 返回的是第一个为假的值

||运算

> ||两个都为真，判断一次，返回第一个为真的值
>
> ||两个为假，判断两次，返回第二个为假的值
>
> ||先假后真，判断两次，返回第一个为真的值
>
> ||先真后假 判断一次 返回第一个为真的值

!非运算

真的为假，假的为真，只有两个值   true和false

*false 0 null undefined '' NaN=>false    转成字符串的时候为假，剩余的为真。



# 9.6

## 执行流程

写代码先写需求，在写代码

### 顺序结构

### 分支结构（选择分路）

分支结构条件：不要有重复，否则逻辑有问题

*单路分支

```js
if(条件){
  //条件成立执行的代码；
}
```



*双路分支

```js
if(条件){
  //条件成立执行的代码；
}else{
  //条件不成立执行的代码；
}
```



*多路分支（条件是一个范围，优先考虑if ；条件是定值，情况可数，优先考虑switch）

```js
if(条件1){
  //条件1成立执行的代码
}else if（条件2）{
  //条件2成立执行的代码
}else if（条件3）{
 // 条件3成立执行的代码；
}...
else{
  //上述条件都不满足执行的代码
}
```

```js
switch(值){
  case 情况1:
    代码；
    break；
  case 情况2:
    代码；
    break；
  case 情况3:
    代码；
    break；
  case 情况4:
    代码；
    break；
  default：
    上述情况都不满足；
}
```



*嵌套分支   没必要嵌套单路分支  嵌套双路或多路

### 循环结构

在满足条件的情况下，不停的执行某一段代码

#### for循环

```js
for(条件初始值；条件最终值；变化量){
  循环体；
}
```



#### while循环

先判断条件，若条件成立，执行循环体，如果条件继续成立，继续执行，直到条件不成立退出循环

```js
while(循环条件){
  循环体；
  变换量；
}
```



#### do while循环

先执行循环体，在判断条件，若满足条件，继续执行，直到条件不成立退出循环

```js

```

do while初始值不满足条件，至少执行一次

while初始值不满足条件，至少执行0次

在知道循环次数的情况下，优先考虑for循环，

在知道循环条件时 考虑while ，do while

#### 跳转循环

continue，跳出当前（本次）循环，如果条件成立，继续执行循环

break，跳出（终止）整个循环，即使条件满足也不会继续循环

continue，break 跳过的都是自己所在的循环体



# 数组

### 优点

> 方便管理数据
>
> 逻辑清晰，代码方便管理维护

### 什么是数组

> 存储一系列相同，相关的数据的容器

## 创建数组

```js
var arr=[]
var arr2=new Array（）
```

*声明之后赋值

```js
var arr=[10,1,2,,4,,5];
arr[0]=1;
arr[1]=12;
```

*通过下标访问

```js
var arr=[1,2,,36,5]
arr[0]
arr[1]
arr[2]
```

> 下标从0开始，最大的下标为arr[arr.length-1]

#### 注意

> 数组元素默认额数值为undefined
>
> 数组的长度是可变的
>
> 数组元素可以是任意的数据类型

#### 遍历

```js
for(var i=0;i<arr.length;i++){
    arr[i];
}
```

# 9.7

## 函数

将实现某一个特定功能的代码段封装。能够重复调用

#### 优点

> 重复调用
>
> 逻辑结构严谨 代码清晰
>
> 方便维护和开发

### 声明函数的方法

基本语法的定义，取个名字，在声明的前后都可以调用

```js
function table(形参1，形参2，...){
  //函数体
  return；
}
形参，return可有可无
```

```js
字面量的定义，声明之前不可以调用，声明之后可调用
var fn=function(){
  alert(1);
}
```

```js
面向对象的
new Function(形参1，形参2)
不常用，不推荐使用
```

### 调用函数

##### *函数名()

##### *事件触发的时候（事件后面）

##### *自调用(立即执行函数)

一边声明一边调用

```js
(function fn(){
  alert(1);
})()
```

#### 注意事项

> 函数名相同，后面的函数覆盖掉原来的函数
>
> 基本语法定义的函数在声明前后都可以调用，以字面量声明的函数只能在声明后才能调用
>
> 基本语法定义的函数会提前加载在内存中，

#### 参数

> 参数通过动态的改变函数体内部的变量，函数灵活强大
>
> 可以是任意的数据类型，函数也是可以的
>
> 参数的名字可以随便，但是传递过来的顺序不能换

##### 参数类型

> 形参：函数定义时小括号里写的值，没有实际的值，接受实参的值
>
> 实参:函数调用小括号里面的值，实参是给形参传递值的
>
> 形参的个数比实参多，多余的形参为undefined；
>
> 实参的个数比形参多，在arguments中会保存，可以用
>
> 带有默认值的参数通通写到参数的最后
>
> 实参如果给值是undefined，那么还会启用默认值

#### arguments

> 函数内部自动生成的对象，只能在函数内部调用，保存了实参所有的详细信息

#### 剩余参数rest

> 接受实参中没有与形参中对应的参数(接受剩余参数)
>
> ...剩余参数名  function fn（arr,...restname）{
> ​    restname}
>
> 数据类型为数组
>
> 没有剩余参数，空数组，不是undefined之类的
>
> 只能写到参数的最后面，否则报错

##### 默认参数

> 参数：传值 传进来的值，不传给默认值
>
> 分支
>
> 三元表达式
>
> ```js
> type = type==undefined?默认值：type
> ```
>
> 逻辑或||
>
> ```js
> type=type||默认值
> ```
>
> ES6直接给，兼容性的问题
>
> ```js
> function fn(arr type='<'){
>
> }
> ```
>
> 实参给的undefined，形参启用的还是默认值
>
> 特点：带有默认性质的参数通通放到最后

#### return

*在函数调用的地方返回一个值，没有返回值，默认返回的是undefined

*用来终止函数的执行，return后面的代码不执行（函数体内的）

*函数的返回值可以是任意的数据类型

*一个函数只能有一个返回值，允许写多个（配合分支结构去写），但是只执行一个

*return：1，2，3；（返回3）

*返回的是变量的，，，值，不是变量

## 作用域

### 环境

#### 宿主

#### 执行

#### 预编译

*按照从上到下的顺序，进入每一个script，一对script标签一对script标签的进入

*var，function 变量名和函数名预先放置内存，记录声明的环境

*记录完了就可以执行了

### 全局作用域（任意位置都可起作用）

> 函数最外层
>
> 变量不用var声明

### 局部作用域

> 定义在函数的里面
>
> 形参也是局部变量
>
> 逻辑清晰，相互之间不作用不影响
>
> 局部变量作用完了就释放内存了，这样比较节省内存
>
> 变量有作用域，函数也有作用域



# 递归函数

# 浅拷贝

```js
var arr=[4,5,6,7];
var arr1=arr;
```

拷贝的就是一个地址，两个数组共同指向同一个区域，所以改一个，两个都改

# 深拷贝

```js
var arr=[4,5,6,7];
var arr1=[];
for(i=0;i<arr.length;i++){
    arr1[i]=arr[i];
}
```

拷贝的是值，arr1已经有自己的空间了，只是把arr的值拿过来，改一个另一个不影响



# 闭包函数

定义一个函数，在函数的里面再定义一个函数，将里面的函数作为返回值返回出来就可以操作它，这就是一个闭包函数

# 箭头函数

(  )=>(  )

# 新的声明方法

### let

*先声明后调用，目的就是规范操作

*基本用法与var一样

*let不存在变量的提升，声明之前不可以调用

*暂时性的死区

*同一个作用域不可以重复的声明同一变量

*块级作用域

```js
{
  let num=90;
  alert(num);  //90
}
alert (num)  //报错，没有定义
```

*块级作用域的嵌套

### var的缺点

> 内存泄露(for)
>
> 局部变量会覆盖全局变量
>
> ```js
> var num='a';
> function fn{
> alert(a);
> if(true){
> var num=10;
> alert(num);
> }
> }
> ```
>

### const

> 在声明的时候就要赋值
>
> 赋值完了不允许修改
>
> 识别块级作用域
>
> 一般用它声明常量(一般把常量声明到文件的最前面，常量一般习惯的定义成大写)

## 内置顶层函数

*内置：js里面自己定义的，只需要关心怎么用，不需要关心如何实现的

*在任意的位置都可调用函数，全局作用域

escape()   对数字，字符以外的字符进行编码

unescape()    对编码后的字符进行解码

Number()    将其他的数据类型转成数字

> 布尔值 true->1   false->0
>
> null->0
>
> undefined->NaN
>
> 数字->数字  ；   进制->十进制； 忽略无意义的0
>
> 必须是规则的数字  10.25.25  报错
>
> 字符串： 数字型的可以转(忽略无意义的0，识别进制)；空字符串转成0；其他的不能转  '12.20.25'->NaN

String()       转成字符串

Boolean()     转成boolean，除了，0，false，undefined，NaN，'',null，剩下的全是真

parseInt()    

> 转成整数
>
> 以数字，正负号，空格开头
>
> 第一个数字字符开始，第一个非数字字符结束

parseFloat()

> 字符串转换为浮点数

isNaN()

> is not a number
>
> 能转换为数字，就返回false，若转不成，就返回true

### 强制类型转换

### 隐式类型转换

> 算术运算符（-  %  /  *）
>
> 比较运算符  
>
> 逻辑运算符
>
> if(  条件  )  可以写关系表达式，也可以写变量
>
> while()
>
> 三元表达式























